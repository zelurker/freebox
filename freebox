#!/bin/bash

ulimit -c unlimited
find cache/ -mtime +3 -delete

function init_mp1 {
service=$1
flavour=$2
audio=$3
video=$4
src=""
chaine=`head -n 1 current`
if [ "$service" == "" ] || [ "$flavour" == "" ]; then
	service=`head -n 3 current|tail -n 1`
	flavour=`head -n 4 current|tail -n 1`
	audio=`head -n 5 current|tail -n 1`
	video=`head -n 6 current|tail -n 1`
	src=`head -n 2 current|tail -n 1`
fi
if [ "$flavour" == "0" ]; then
	flavour=""
fi
if [ "$audio" == "0" ]; then
	audio=""
fi
if [ "$video" == "0" ]; then
	video=""
fi
if echo $src|grep -q Fichiers && ! [ -f "$service" ]; then
	# Fichier introuvable en mode Fichiers
	service=""
fi
if [ "$service" == "" ]; then
	# reset to 1st working channel then
	service=201
	flavour=sd
	video=""
	audio=""
	src=freeboxtv
	chaine="France 2"
fi
echo service $service flavour $flavour source $src
cmd=""
# append initialilsé par les appels à append
append $flavour
append $audio
append $video
echo ./run_mp1 "$service" $cmd "$src" "$chaine"
./run_mp1 "$service" $cmd "$src" "$chaine"
}

function append {
  if [ "$1" = "" ]; then
	  cmd="$cmd 0"
  else
	  cmd="$cmd $1"
  fi
}

function launch() {
	rm -f fifo fifo_cmd
	mkfifo fifo fifo_cmd
	# On récupère le nom à jour
	name=`head -n 7 current|tail -n 1|sed 's/ http.*//'`
	bmovl=bmovl=1:0:fifo,
	if echo $src|grep -q flux; then
		echo "lancement flux name=$name"
		if echo $name|grep -q mms || echo $src|grep -q youtube; then
			# Très approximatif comme détection mais en tous cas les flux
			# vidéo mms, particulièrement france 2, nécessitent du cache.
			cache=1000
		else
			# 100 c'est bien, ça fait un démarrage super rapide des flux audios
			# et c'est suffisant dans la plupart des cas
			cache=100
		fi
		cd=`grep "drive name" /proc/sys/dev/cdrom/info|
		sed 's/drive name:[ \t]*//'`
		echo mplayer2 -cdrom-device "/dev/$cd" "$name" -quiet -cache $cache \
			-stop-xscreensaver -identify -idle -input \
			nodefault-bindings:conf=$PWD/input.conf:file=fifo_cmd -vf \
			$bmovl"screenshot"
		mplayer2 -cdrom-device "/dev/$cd" "$name" -quiet -cache $cache \
			-stop-xscreensaver -identify -idle -input \
			nodefault-bindings:conf=$PWD/input.conf:file=fifo_cmd -vf \
			$bmovl"screenshot" 2>&1 \
			| perl filter_mplayer.pl &
	else
		if [ "$audio" != "" ]; then
			audio2="-aid $audio"
		fi
		mplayer=mplayer2
		idle=""
		if [ "$src" != "Fichiers vidéo" ]; then
			filter=",kerndeint"
		else
			if ! echo $chaine|grep -q -i mpg$ && !echo $chaine|grep -q ts$; then
				filter=""
			else
				filter=",kerndeint"
			fi
			idle="-idle"
		fi
		if [ "$src" == "freeboxtv" ] || [ "$src" == "dvb" ]; then
			# L'index n'est pas dynamique pour les fichiers ts dans mplayer2
			# ce qui veut dire qu'on ne peut seeker au delà de la fin détectée
			# du fichier quand on commence la lecture, ça fait pas beaucoup !
			mplayer=mplayer
		fi
		echo $mplayer $idle $audio2 $length -vf $bmovl"screenshot$filter" \
			-cache 100 -stop-xscreensaver -identify -input \
			nodefault-bindings:conf=$PWD/input.conf:file=fifo_cmd $demuxer \
			"$name" avec filtre en pipe

			$mplayer $idle $audio2 $length \
				-vf $bmovl"screenshot$filter" -cache 100 \
				-stop-xscreensaver -identify -input \
				nodefault-bindings:conf=$PWD/input.conf:file=fifo_cmd $demuxer \
				"$name" 2>&1 | perl filter_mplayer.pl &
	fi
	echo $! > player2.pid
	audio2=""
}

exit=0
rm -f id fifo_list video_size
# 1st kill all the old eventual processes
for n in player1.pid; do
	if [ -f $n ]; then
		kill `cat $n` >& /dev/null
		rm -f $n
	fi
done
if ! [ -f info.pid ]; then
	./bmovl-src/bmovl fifo &
fi	
if ! ps -p `cat info_pl.pid`>&/dev/null; then
	perl info.pl &
fi
if [ ! -f info_list.pid ]; then
	perl list.pl &
elif ( ! [ -f player2.pid ] || ! ps -p `cat player2.pid` || ! ps -p `cat info_list.pid` ); then
	kill `cat info_list.pid` >& /dev/null && rm -f info_list.pid
	perl list.pl &
fi
init_mp1 "$1" $2 $3 $4 $5
name=`head -n 7 current|tail -n 1`
if ! [ -f current ] || [ -f "$name" ] || echo $src|grep -q flux; then

	again=1
	# Cette boucle est pour récupérer la main quand on sort par erreur du
	# fichier par la fin. On doit boucler sur l'identification du fichier parce
	# que c'est réutiliser par eval_end.pl pour estimer où commencer la reprise
	# inconvénient majeur : ça ralentit la reprise
	while [ "$again" == "1" ]; do
		# En cas de zapping, on se retrouve ici, faut remettre à jour chaine
		chaine=`head -n 1 current`

		if [ -f player2.pid ] && ps -p `cat player2.pid` >& /dev/null; then
			# kill le 2ème process le + tard possible pour minimiser la
			# disparition de la fenêtre pendant le zapping
			echo quit > fifo_cmd
			rm -f player2.pid
		fi
		if [ -f info.pid ]; then
			if ! ps -p `cat info.pid` >& /dev/null; then
				rm -f info.pid
			fi
		fi
		name=`head -n 7 current|tail -n 1`
		# Le -frames 0 ici est totalement obligatoire sinon ça peut être
		# très long sur certains fichiers h264 !
		if ! ( echo "$src"|grep -q flux ) && [ "$name" != "" ]; then
			mplayer2 -identify -vo null -ao null -frames 0 "$name" > id
			if grep -q "no video" id || grep -q "NO AUDIO" id || \
				grep -q "AUDIO_CODEC=ffaac" id; then
			# En fait c'est pas toutes les vidéos hd qui ont un problème,
			# seulement celles qui ont du aac dedans.
			# Dommage parce que le demuxer lavf explose complètement l'index
			# ce qui est très énervant...
				demuxer="-demuxer lavf -framedrop "
				echo lavf activé
			else
				demuxer=""
			fi
		fi
		launch
		pid=$!
		wait $pid
		src=`head -n 2 current|tail -n 1`
		length=""
		if ! echo "$src" |grep -q "flux" && ! echo $src|grep -q Fichiers; then
			length=`perl eval_end.pl`
		fi
		if [ "$length" != "0" ] && [ "$length" != "" ]; then
			length="-ss $length"
			rm -f list_coords info_coords mode_coords
		else
			length=""
		fi

		again=1
		if grep -q ID_EXIT=QUIT id &&
			! grep -q ID_SIGNAL=15 id && ! grep -q "End of file" id; then
			echo sortie sur ID_EXIT=QUIT
			again=0
		fi
	done
	echo sortie de boucle again=$again
	for n in player1.pid info_list.pid; do
		if [ -f $n ]; then
			kill `cat $n` >& /dev/null
			rm -f $n
		fi
	done
	rm -f player2.pid
fi
rm -f info_coords list_coords numero_coords mode_coords fifo fifo_cmd
kill `cat info.pid`


