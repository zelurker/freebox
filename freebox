#!/bin/bash

ulimit -c unlimited
find cache/ -mtime +3 -delete

function init_mp1 {
service=$1
flavour=$2
audio=$3
video=$4
src=""
chaine=`head -n 1 current`
if [ "$service" == "" ] || [ "$flavour" == "" ]; then
	service=`head -n 3 current|tail -n 1`
	flavour=`head -n 4 current|tail -n 1`
	audio=`head -n 5 current|tail -n 1`
	video=`head -n 6 current|tail -n 1`
	src=`head -n 2 current|tail -n 1`
fi
if [ "$flavour" == "0" ]; then
	flavour=""
fi
if [ "$audio" == "0" ]; then
	audio=""
fi
if [ "$video" == "0" ]; then
	video=""
fi
if [ "$service" == "" ]; then
	# reset to 1st working channel then
	service=201
	flavour=sd
	video=""
	audio=""
	src=freeboxtv
fi
echo service $service flavour $flavour source $src
cmd=""
# append initialilsé par les appels à append
append $flavour
append $audio
append $video
./run_mp1 "$service" $cmd "$src" "$chaine"
}

function append {
  if [ "$1" = "" ]; then
	  cmd="$cmd 0"
  else
	  cmd="$cmd $1"
  fi
}

function launch() {
	rm -f fifo fifo_cmd
	mkfifo fifo fifo_cmd
	# On récupère le nom à jour
	name=`head -n 7 current|tail -n 1`
	if [ "$src" == "flux" ]; then
		echo "lancement flux name=$name"
		if echo $name|grep mms; then
			# Très approximatif comme détection mais en tous cas les flux
			# vidéo mms, particulièrement france 2, nécessitent du cache.
			cache=1000
		else
			# 100 c'est bien, ça fait un démarrage super rapide des flux audios
			# et c'est suffisant dans la plupart des cas
			cache=100
		fi
		cd=`grep "drive name" /proc/sys/dev/cdrom/info|
		sed 's/drive name:[ \t]*//'`
		if echo $name|grep pls; then
			prefix="-playlist "
		else
			prefix=""
		fi
		echo mplayer -cdrom-device "/dev/$cd" $prefix "$name" -quiet -cache $cache \
			-stop-xscreensaver -identify -input \
			conf=$PWD/input.conf:file=fifo_cmd
		mplayer -cdrom-device "/dev/$cd" $prefix "$name" -quiet -cache $cache \
			-stop-xscreensaver -identify -input \
			conf=$PWD/input.conf:file=fifo_cmd \
			| perl filter_mplayer.pl &
	else
		if [ "$audio" != "" ]; then
			audio2="-aid $audio"
		fi
		bmovl=bmovl=1:0:fifo,
		mplayer=mplayer
		if echo $src|grep -q Fichiers; then
			# Bug sur la version de dév de mplayer relative à bmovl sur les
			# fichiers. C'est lié au fps, mais dur à délimiter. Contournement:
			# utiliser une vieille version !
			mplayer=/usr/bin/mplayer
		fi
		echo $mplayer $audio2 -quiet $length -vf $bmovl"screenshot,kerndeint" \
			-stop-xscreensaver -identify -input \
			conf=$PWD/input.conf:file=fifo_cmd $demuxer \
			"$name" avec filtre en pipe

			$mplayer $audio2 -quiet $length -vf $bmovl"screenshot,kerndeint" \
				-stop-xscreensaver -identify -input \
				conf=$PWD/input.conf:file=fifo_cmd $demuxer \
				"$name" | perl filter_mplayer.pl &
	fi
	echo $! > player2.pid
	audio2=""
}

exit=0
while [ "$exit" != "1" ]; do
	rm -f id fifo_list video_size
	# 1st kill all the old eventual processes
	for n in player1.pid; do
		if [ -f $n ]; then
			kill `cat $n` >& /dev/null
			rm -f $n
		fi
	done
	if ! [ -f info.pid ]; then
		./bmovl-src/bmovl fifo &
	fi	
	if ! ps -p `cat info_pl.pid`>&/dev/null; then
		perl info.pl &
	fi
	if [ ! -f info_list.pid ]; then
		perl list.pl &
	elif ( ! [ -f player2.pid ] || ! ps -p `cat player2.pid` || ! ps -p `cat info_list.pid` ); then
		kill `cat info_list.pid` >& /dev/null && rm -f info_list.pid
		perl list.pl &
	fi
	init_mp1 "$1" $2 $3 $4 $5
	name=`head -n 7 current|tail -n 1`
	if [ -f "$name" ] || [ "$src" == "flux" ]; then

		again=1
		# Cette boucle est pour récupérer la main quand on sort par erreur du
		# fichier par la fin. On doit boucler sur l'identification du fichier parce
		# que c'est réutiliser par eval_end.pl pour estimer où commencer la reprise
		# inconvénient majeur : ça ralentit la reprise
		while [ "$again" == "1" ]; do
			# En cas de zapping, on se retrouve ici, faut remettre à jour chaine
			chaine=`head -n 1 current`
			if [ "$src" != "flux" ] && ! echo $src|grep -q Fichiers; then
				cp -f current current0
			fi

			if [ -f player2.pid ] && ps -p `cat player2.pid` >& /dev/null; then
				# kill le 2ème process le + tard possible pour minimiser la
				# disparition de la fenêtre pendant le zapping
				echo quit > fifo_cmd
				rm -f player2.pid
			fi
			if [ -f info.pid ]; then
				if ! ps -p `cat info.pid` >& /dev/null; then
					rm -f info.pid
				fi
			fi
			name=`head -n 7 current|tail -n 1`
			# Le -frames 0 ici est totalement obligatoire sinon ça peut être
			# très long sur certains fichiers h264 !
			if [ "$src" != "flux" ]; then
				mplayer -identify -vo null -ao null -frames 0 "$name" > id
				if grep -q "no video" id || grep -q "NO AUDIO" id || \
					grep -q "H264" id; then
					demuxer="-demuxer lavf -framedrop "
					echo lavf activé
				else
					demuxer=""
				fi
#				fps=`grep ID_VIDEO_FPS id|cut -d = -f 2|sed 's/\..*//'`
#				if [ "$fps" -gt 30 ]; then
#					no_bmovl=1
#				else
#					no_bmovl=0
#				fi
			fi
			launch
			pid=$!
			if ! [ -f info.pid ]; then
				./bmovl-src/bmovl fifo &
			fi
			wait $pid
			src=`head -n 2 current|tail -n 1`
			if [ "$src" != "flux" ] && ! echo $src|grep -q Fichiers; then
				length=`perl eval_end.pl`
			fi
			if [ "$length" != "0" ] && [ "$length" != "" ]; then
				length="-ss $length"
				rm -f list_coords info_coords
			else
				length=""
			fi

			src=`head -n 2 current|tail -n 1`
			if [ -f live ]; then
				rm -f live
				if ! grep -q ID_EXIT=QUIT id; then
					echo switch_mode $src > fifo_list
					init_mp1
					again=1
				fi
			fi
			# echo end of while loop length $length again $again
			audio=`head -n 5 current|tail -n 1`
			again=1
			if grep -q ID_EXIT=QUIT id &&
			   	! grep -q ID_SIGNAL=15 id && ! grep -q "End of file" id; then
				echo sortie sur ID_EXIT=QUIT
				again=0
			fi
		done
		echo sortie de boucle again=$again
		for n in player1.pid info_list.pid; do
			if [ -f $n ]; then
				kill `cat $n` >& /dev/null
				rm -f $n
			fi
		done
		rm -f player2.pid
	fi
	rm -f info_coords list_coords numero_coords
#	if [ "$src" != "flux" ] || cmp current current0 > /dev/null; then
# Sortie sans test des flux, je veux pouvoir garder un flux comme chaine par
# défaut pour rester sur une radio quand on revient
		exit=1
#	else
#		cp -f current0 current
#	fi
if echo $src|grep -q Fichiers; then
	cp -f current0 current
	exit=0
fi

done
kill `cat info.pid`


