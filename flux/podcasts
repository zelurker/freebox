#!/usr/bin/perl

use strict;
use Date::Parse;
# xml::simple est vraiment obligatoire ici, format xml trop variable
use XML::Simple;
use Data::Dumper;
use WWW::Mechanize;

# Refonte complète, on abandonne podcasters qui est pourri finalement
# et on ne va garder que des résultats google pour les recherches...
#
# C'est un peu long pour un plugin mais c'est + simple que celui de youtube
# (jusqu'ici en tous cas !). En gros :
# 1ère partie : détection du type de requête à faire, exactement comme
# youtube, mais faire un module pour ça ne serait pas très pratique
# 2 - décodage du xml des podcasts avec xml::simple

my $f;
my @abo;
my $fpod = "$ENV{HOME}/.freebox/podcasts";
if (open($f,"<$fpod")) {
	@abo = <$f>;
	close($f);
	chomp @abo;
}
binmode STDERR; # ,":utf8";
binmode STDOUT, ":iso8859-15"; # ,":utf8";
my $str = shift @ARGV;
my $debug = 1; # infos
my $dump = 0;  # dump toute l'entrée ligne par ligne
$str =~ s/^result\://;
if ($str =~ /^(.+) (http.+)/) { # demande d'abonnement
	my $title = $1;
	$str = $2;
	push @abo,$title;
	push @abo,$2;
	if (open($f,">$fpod")) {
		print $f join("\n",@abo);
		close($f);
	}
}
if ($str =~ /http/) {
	print STDERR "str $str sending direct\n";
	print "direct\n";
} else {
	print STDERR "str $str sending list\n";
	print "list\n";
}
print "Recherche\nRecherche\n"; # Transmis en mode list (ne contient pas //)
print "Abonnements\n+Abonnements\n" if (@abo);
if ($str eq "Abonnements") {
	print join("\n",@abo);
	exit(0);
}
$str =~ s/ /\+/g;
my $mech = WWW::Mechanize->new();
$mech->agent_alias("Linux Mozilla");
$mech->timeout(10);
$mech->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
my ($r,$type);
if ($debug && !$str) {
	binmode STDIN; # ,":utf8";
	@_ = <>;
	$_ = join("",@_);
	$str = "http";
	print STDERR "debug mode, input from stdin\n";
} else {
	if ($str && $str !~ /^http/) {
		print STDERR "requête de recherche sur $str\n"; # if ($debug);
		$mech->get("https://www.google.fr/");
		$r = $mech->submit_form(
			form_number => 1,
			fields      => {
				q => "podcast $str filetype:xml",
			}
		);
	} elsif ($str) {
		print STDERR "debug: get $str\n" if ($debug);
		$r = $mech->get($str);
	}
	$_ = $mech->content;
	$type = $r->header("content-type") if ($r);
}

my $encoding = "";

my $content = 0;
my ($link,$title,$desc,$img,$date);
print STDERR "*** type $type\n";
if (/^<\?xml/ || /^<rss xml/ || $type =~ /(application|text).xml/) {
	# Sauver le fichier pour l'information programmes (prog/podcasts.pm)
	$mech->save_content("pod");
	# Normalement on devrait pas avoir à faire ça, mais y a xml::simple qui
	# fait du découdage partiel très foireux quand le source est utf8 et
	# que la locale n'est pas utf8 !
	if ($encoding =~ /utf/i) {
		binmode STDOUT, ":utf8";
	} else {
		binmode STDOUT, ":encoding(iso8859-15)" if ($ENV{LANG} =~
		/(euro|ISO-8859-1)/);
	}
	s/\xe2\x80\x99/'/gs;
	s/(&[^a])/&amp;/g;
	print STDERR "décodage xml\n" if ($debug);
	# fichier xml podcast
	my $found = 0;
	foreach (@abo) {
		if ($_ eq $str) {
			$found = 1;
			last;
		}
	}
	print STDERR "trouvé abonnement\n" if ($found && $debug);

	s/\r//gm;
	my $ref = XMLin($_);
	if (!$found) {
		my $title = $ref->{channel}->{title};
		print "S'abonner\n$title $str\n";
	}

	my $item = $ref->{channel}->{item};
	# Vu que certains podcasts n'arrivent pas dans l'ordre, trie par date
	my @item = sort { my $c = $a->{pubDate}; my $d = $b->{pubDate};
	# print "avant $c et $d\n";
	if ($c !~ /^\d+$/) {
		$c =~ s/Mars/Mar/;
		$d =~ s/Mars/Mar/;
		$c = str2time($c);
		$d = str2time($d);
	}
	# print "tri $c et $d\n";
	$d <=> $c;
	} @$item;
	foreach (@item) {
		# A priori ça ne semble pas être une bonne idée de coller l'image ici
		# j'ai jamais vu ces images changer pour chaque épisode et généralement
		# elles sont assez grosses donc elles seront mieux dans le bandeau
		# d'info. Je laisse quand même le code en commentaire au cas où...
		# my $img = $_->{"media:thumbnail"}->{url};
		# print "pic:$img " if ($img && $nb++ <= 10);
		print $_->{title};
# 		my $desc = $_->{"itunes:subtitle"};
# 		if (ref($desc) eq "HASH") {
# 			if (!keys %$desc) {
# 				$desc = "";
# 			} else {
# 				die Dumper($desc);
# 			}
# 		}
# 		$desc =~ s/\n/ /gs;
# 		$desc =~ s/\r//g;
# 		print " - $desc" if ($desc);
		my $date = $_->{pubDate};
		$date = str2time($date) if ($date !~ /^\d+$/);
		print " le ".get_date($date) if ($date);
		print "\n",$_->{enclosure}->{url},"\n";
	}
}

foreach ($mech->links) {
	my $u = $_->url;
	if ($u =~ /url.q=(http.+?)&/) {
		$u = $1;
		print $_->text,"\n$u\n";
		print STDERR "text: ",$_->text," url $u\n";
	}
}

sub get_date {
	my $time = shift;
	my ($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
	sprintf("%d/%02d/%02d, %02d:%02d",$mday,$mon+1,$year+1900,$hour,$min);
}

