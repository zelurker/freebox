#!/usr/bin/perl

use Cpanel::JSON::XS qw(decode_json);
use HTML::Entities;
use strict;
use link_get;
require "http.pl";
use v5.10;
use Data::Dumper;

# binmode STDOUT,":utf8";
my $str = shift @ARGV;
my @arg = split(/\//,$str);
my $utf = $ENV{LANG} =~ /utf/i;

sub decode_prg {
    $_ = shift;
    if (ref($_) eq "ARRAY") {
        foreach (@$_) {
            if ($_->{programId}) {
                say $_->{title},($_->{subtitle} ? " - ".$_->{subtitle} : "");
                my $url = $_->{url};
				$url = "http://www.arte.tv$url" if ($url !~ /^http/);
                $url =~ s/\//|/g; # pour que l'url puisse être passée en argument, on a pas le droit au /
                    say "$str/vid:$_->{programId},$url";
            } else {
# apparemment ça peut arriver... !
                say STDERR "decode_prg: pas de programid pour ça : ".Dumper($_);
            }
        }
    } else {
        die "deocde_prg: pas de tableau ?";
    }
}

sub decode_type {
# décodage catégorie
    $_ = shift;
    if (ref($_) eq "ARRAY") {
        foreach (@$_) {
            if ($_->{type}) { # catégories de vidéos
                if (!$arg[0] && $_->{title}) {
# Note : y a des entrées sans titre avec comme type "banner", mais y en a
# plusieurs. Je suppose que c'est lié aux vidéos
# affichées dans la bannière de haut d'écran, on laisse
# tomber à priori...
                    print $_->{title}."\n$_->{code}\n";
                } elsif ($_->{code} eq $arg[0] || $_->{title} eq $arg[0]) {
                    decode_prg($_->{teasers});
                }
            } else {
                die "deocde_type: reconnais pas ça : ".Dumper($_);
            }
        }
    } else {
        die "decode_type: pas de tableau ?";
    }
}

sub decode_main {
    $_ = shift;
    if (ref($_) eq "HASH") {
        my %hash = %$_;
        if ($hash{tvguide}) { # racine du nouveau hash 2017
            return decode_type($hash{page}{zones});
        } else {
            die "decode_main: pas de tvguide";
        }
    }
    die "decode_main: pas de hash ?";
}

if ($arg[$#arg] =~ /vid:(.+)/) {
# On demande une vidéo !
    my $code = $1;
    my $url0;
    ($code,$url0) = split(/,/,$code);
    $url0 =~ s/\|/\//g;
    say STDERR "url0 $url0";
    if (open(F,">cache/arte/last_serv")) {
        print F $str;
        close(F);
    }
    my $url = "https://api.arte.tv/api/player/v1/config/fr/$code?platform=ARTEPLUS7&lang=fr_FR";
    my $streams = myget($url,"cache/arte/$code",7);
    my $json = decode_json($streams);
    my $hash = $json->{videoJsonPlayer}{VSR};
    if (!$hash || ref($hash) ne "HASH") {
        say STDERR "vid: ref(hash) = ",ref($hash)," calling myget url0=$url0";
# 1 on récupère la page html liée
        my $html = myget($url0,"cache/arte/$code.html",7);
# on récupère l'url de l'iframe video...
        ($url) = $html =~ /iframe allow.+?src="(.+?)"/;
		if (!$url) {
			# dans ce cas là, c'est une page d'index probablement
			if ($html =~ /__INITIAL_STATE__ = (.+);/) {
				$json = decode_entities($1);
				eval  {
					$json = decode_json( $json);
				};
				if ($@) {
					die "arte: couille dans le potage au niveau json $?:$@\n";
				}
			} else {
				die "pas trouvé le json cache cache/arte/$code.html";
			}
			$str =~ s/\/vid:.+//;
			say "encoding: latin1";
			say "list";
			say STDERR "flux/arte: calling decode_prog sur liste";
			decode_prg($json->{collection}{videos});
			exit(0);
		}
        my $player = myget($url,"cache/arte/$code.player",7);
        ($json) = $player =~ /js_json = (.+?);/;
        $json = decode_json($json);
        $hash = $json->{videoJsonPlayer}{VSR};
    }
    print "direct\n";
    foreach (sort { $a cmp $b } keys %$hash) {
        my $h = $hash->{$_};
        next if ($h->{mediaType} eq "hls"); # hls c'est du m3u, on en veut pas!
            print "$h->{mediaType} $h->{width}x$h->{height} @ $h->{bitrate}kbps $h->{versionLibelle}\n";
        if ($h->{streamer}) {
            print "get,$h->{streamer}$h->{url}\n";
        } else {
            print "get,$h->{url}\n";
        }
    }
    exit(0);
} elsif ($str =~ /^get,(.+)/) {
    my $url = $1;
    my ($file) = $url =~ /.+\/(.+?)$/;
    $file = "cache/arte/$file";
    print STDERR "arte: file $file from url $url\n";
    link_get::link_get($file,$url);
}

print "encoding: latin1\nlist\n";

my $page = myget("http://www.arte.tv/guide/fr/plus7/","cache/arte/j0",1/24.0);
my $capture = 0;
my $json;
# le json dans de l'html c'est toujours merdique, ça vient de changer en
# avril 2017... !
foreach (split(/\n/,$page)) {
    if (/__INITIAL_STATE__ = (.+);/) {
        $json = decode_entities($1);
    }
}
eval  {
    $json = decode_json( $json);
};
if ($@) {
    print STDERR "arte: couille dans le potage au niveau json $?:$@\n";
    exit(0);
}
decode_main($json);
