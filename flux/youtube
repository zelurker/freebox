#!/usr/bin/perl

use strict;
require "http.pl";

binmode STDERR; # ,":utf8";
binmode STDOUT; # ,":utf8";
my $str = shift @ARGV;
my $debug = 0; # infos
my $dump = 0;  # dump toute l'entrée ligne par ligne
$str =~ s/^result\://;
if ($str =~ /http/) {
	print STDERR "str $str sending direct\n";
	print "direct\n";
} else {
	print STDERR "str $str sending list\n";
	print "list\n";
}
print "Recherche\nRecherche\n"; # Transmis en mode list (ne contient pas //)
$str =~ s/ /\+/g;
if ($debug && !$str) {
	# Mode debug : on lit à partir de stdin, passer une page sauvée de youtube
	# de préférence
	binmode STDIN; # ,":utf8";
	@_ = <>;
	$_ = join("",@_);
	# On passe str = "http" quand c'est le traitement d'une page de vidéo
	# passer str="" pour un index de vidéos
	$str = "http";
} else {
	if ($str && $str !~ /^http/) {
		$_ = myget( "http://www.youtube.com/results?search_query=$str&oq=$str");
	} elsif ($str) {
		print "debug: get $str\n" if ($debug);
		$_ = myget($str);
	} else {
		$_ = myget("http://www.youtube.com/");
	}
}
if (/encoding="(.+?)"/) {
	print "encoding: $1\n";
}

open(F,">yt.html");
print F $_;
close(F);
if ($str =~ /^http/) {
	# Extrait les formats vidéos de la page
	my ($title) = /<title>(.+?)<\/title/;
	my $start_tag = "url_encoded_fmt_stream_map";
	# $start_tag = "adaptive_fmts" if (!/sig=/);
	handle_tag($start_tag,$title);

	# adaptive_fmts : sépare le flux vidéo et audio dans 1 flux séparé, permet
	# + de choix, et y a une + haute qualité vidéo. Par contre ça met + de temps
	# à démarrer, les serveurs ont l'air de vouloir un délai de démarrage
	# imposé, peut-être pour la pub. Donc je les garde, mais en optionnel en fin
	# de liste.
	handle_tag("adaptive_fmts",$title) if (/adaptive_fmts/);
	my ($suffix) = $str =~ /v=(.+)/;
	mkdir "cache/yt";
	# On aimerait bien sauver sous le nom du suffix pour qu'il soit unique,
	# sauf qu'il n'arrive jamais jusqu'au bandeau d'info, ça reste une
	# valeur intermédiaire gérée par list vu que le dernier argument est la
	# vidéo elle même... Résultat : faut utiliser le titre !!!
	open(F,">cache/yt/$title");
	my ($upload) = $_ =~ /div id="watch-uploader-info">(.+?)<\/div/;
	my ($info) = $_ =~ /div id="watch-description-text".*?>(.+?)<\/div/;
	print F "$suffix\n", # on met le suffix parce qu'on peut récupérer l'image
	"$upload\n$info\n";
	close(F);
	exit(0);
}
my ($name,$url);
my %list = ();
my $content = 0;
my ($link,$text,$img,$data_text,$data_link);
foreach (split /\n/) {
	s/\&\#(..)\;/chr($1)/ge;
	print "debug:$_\n" if ($dump);
	# A priori les content ne sont plus utilisés, faudrait faire le ménage
	# un de ces 4... enfin pour l'instant je laisse ça là...
	if (/div class="result-item-main-content/ ||
		/class="yt-lockup-ellipsize"/) {
		$content = 1;
		print STDERR "*** debug: content $content\n" if ($debug);
	}
	if (/div class="feed-item-content"/) {
		$content = 2;
		print STDERR "*** debug: content $content\n" if ($debug);
	}
	if (/div class="yt-lockup2/) {
		# Autres résultats de recherche
		$content = 3;
		print STDERR "*** debug: content $content\n" if ($debug);
	}
	# Note : le texte du titre est apparemment souvent sur la même ligne
	# que l'image d'après, donc il faut absolument traiter ça en 1er !
	if (/yt-lockup-title.+?title="(.+?)"/) {
		$data_text = $1;
		print STDERR "debug: data_text = $data_text\n" if ($debug);
	}
	if ($data_link && $data_text) {
		if ($img =~ /^\/\//) {
			$img = "http:$img";
		} elsif (!$img) {
			my ($id) = $data_link =~ /v=(.+)/;
			# On reconstitue l'image à partir de l'id vidéo, ça vaut mieux,
			# tout se mélange là-dedans !
			$img = "http://i.ytimg.com/vi/$id/mqdefault.jpg";
			print STDERR "image reconstituée d'après id video\n" if ($debug);
		}
		if ($debug) {
			print STDERR "debug: data pic $img link $data_link text $data_text\n";
		} else {
			print ($img ? "pic:$img " : "");
			if (!utf8::valid($data_text)) {
				die "problème $data_text\n";
			}
			print $data_text;
			print "\nhttp://www.youtube.com$data_link\n";
		}
		$data_link = $data_text = $img = "";
	}

	if (/href="(.+?)".*yt-thumb-simple.+?src="(.+?)"/) {
		$link = $1;
		my $truc = $2;
		if ($truc =~ /jpg$/) {
			$img = $truc;
			# Le texte doit être en dernier !!!
			$data_text = undef;
			print STDERR "debug: img = $truc link $link (ident clip-inner)\n" if ($debug);
		}
#		} elsif ($debug) {
#			print STDERR "debug: failed to recognize image $truc (ident clip-inner\n";
	}
	$img = $1 if (/data\-thumb="(.+?)"/);
   	if (/data-sessionlink.*href="(.+?)"/ || /href="(.+?)".*data-sessionlink/) {
		$data_link = $1;
		$data_link = "" if ($data_link !~ /watch/);
		print STDERR "debug: data_link = $data_link\n" if ($debug);
	}
	if ($content == 1) {
		if (/href="(\/.+?)".*?\>(.+)<\/a/) {
			my ($url,$text) = ($1,$2);
			$img = "http:$img" if ($img =~ /^\/\//);
			print ($img ? "pic:$img " : "");
			print "$text\nhttp://www.youtube.com$url\n";
			$img = undef;
			$content = 0;
		}
	} elsif ($content == 3) {
		if (/yt-lockup2-title.*title="(.+?)"/) {
			$_ = $1;
			$img = "http:$img" if ($img =~ /^\/\//);
			if ($debug) {
				print STDERR "debug: content3 pic $img link $link text $_\n";
			} else {
				print ($img ? "pic:$img " : "");
				print "$_\nhttp://www.youtube.com$link\n";
			}
			$link = $content = undef;
		}
	}
}

sub handle_tag {
	# Cette sub récupère les différents formats vidéos d'une page, y en a
	# de 2 sortes qui sont déterminés par start_tag :
	# url_encoded_fmt_map qui est le format par défaut
	# adaptive_fmt qui fournit une résolution et une piste audio séparée !
	# Le gros problème de cette sub est la signature qu'il faut régénérer
	# toutes les 24h environ, chaque facile à décoder, mais chaque fois
	# différente... je suis un peu paumé pour un algo générique pour
	# l'instant...
	my ($start_tag,$title) = @_;
	my $last = "";
	print STDERR "handle_tag start_tag $start_tag title $title.\n" if ($debug);
	while (s/\"$start_tag\": ?\"(.+?)\"//) {
		print STDERR "in while\n" if ($debug);
		my $url = $1;
		$url =~ s/\\\//\//g;
		$url =~ s/%(..)/chr(hex($1))/ge;
		$url =~ s/generate_204/videoplayback/g;
		$url =~ s/\\u(....)/chr(hex($1))/ge;
		my ($tag) = $url =~ /^(.+?)\=/;
		print STDERR "starting tag $tag\n" if ($debug);
		my (@name,@url);
		my $audio;
		while ($url =~ s/($tag=.+?)(,$tag=|$)/$2/) {
			my $u = $1;
			$u =~ s/\\\//\//g;
			while ($u =~ s/%(..)/chr(hex($1))/ge) {}
			$u =~ s/generate_204/videoplayback/g;
			$u =~ s/\\u(....)/chr(hex($1))/ge;
			# L'url arrive avec la plupart de ses arguments encodés, et une
			# partie en clair (et pour certains doublés, comme itag). Passer
			# itag en double provoque un 403, donc le + simple c'est de tout
			# remettre à plat en récupérant tout dans un hash et en éliminant
			# ce qu'on veut pas
			print STDERR "url $u\n" if ($debug);
			my @args = split(/[\?\&]/,$u);
			my %args;
			foreach (@args) {
				my ($name,$val) = split(/=/);
				$args{$name}=$val;
			}
			my $type = delete $args{type};
#			# Ca valait le coup d'essayer, mais apparemment requiressl ne
#			change pas grand chose, si on essaye de le coller à no on prend
#			toujours un 403 en http, et aucun flux en https. Vaut mieux pas
#			toucher !
#			if ($args{requiressl}) {
#				$args{requiressl} = "no";
#				$args{url} =~ s/https/http/;
#			}
			my $s;
			if (!$args{s} && $args{signature}) {
				$args{s} = $args{signature};
			}
			if ($args{sig}) {
				$s = delete $args{sig};
				print STDERR "*** sig1: $s\n";
			} elsif ($args{s}) {
				# L'encodage de la signature est en fonction da la longueur de s
				# problème : je ne connais pas toutes les longueurs possibles
				# ça a changé 1 fois en 2 jours, y en a probablement d'autres
				print STDERR "s $args{s} len ",length($args{s}),"\n" if ($debug);
				if (length($args{s}) == 81) {
					$s = $args{s};
				} elsif (length($args{s}) == 86) {
					# url de départ
					# Y a probablement l'explication de leur codage de
					# signature dans ces paramètres, je pencherais pour
					# fexp, mais pour l'instant, c'est très obscur !!!
					#
					# https://r6---sn-25ge7nls.googlevideo.com/videoplayback?requiressl=yes&ipbits=0&
					# fexp=9406819,9408710,9414602,9416126,9417683,9418203,9418751,9420452,9420771,9422596,9422618,9423241,9423329,9423662,9424163,9424428,9424713,9425308&
					# clen=2993338&
					# mime=video/mp4&
					# gir=yes&mm=31&mn=sn-25ge7nls&
					# itag=160&mt=1449581375&mv=m&ms=au&sver=3&
					# dur=217.600&gcr=fr&
					# ip=2001:41d0:fe0b:6d00:7a34:fe66:1360:c62f&
					# lmt=1417346102810277&
					# id=o-AAkOGD8yzVt587O-Se0Y4JHXZ9Vd7wxonDG0hHn8Clgz&
					# expire=1449603143&
					# nh=IgpwcjAxLnBhcjEwKgkxMjcuMC4wLjE&upn=OFeI1Ltet3M&
					# keepalive=yes&source=youtube&
					# sparams=clen,dur,gcr,gir,id,initcwndbps,ip,ipbits,itag,keepalive,lmt,mime,mm,mn,ms,mv,nh,pl,requiressl,source,upn,expire&
					# initcwndbps=2747500&
					# key=yt6&
					# pl=47&itag=160&
					# s=232395E582AFBC4E64D6F0E921EEBD41837D6D1339.F3F7CE0350EB5B275216FB254D12DA15B9421A76A77&init=0-672&size=192x144&index=673-1196&fps=13
					# &bitrate=111831,lmt=1449572842523717
					$s = $args{s};
					my $post = substr($s,length($s)-1,1);
					my $pre = substr($s,0,1);
					$s = reverse substr($s,0,83);
					substr($s,81-1,1) = substr($s,31-1,1);
					substr($s,31-1,1) = $pre;
					substr($s,64-1,1) = substr($s,13-1,1);
					substr($s,13-1,1) = $post;

					$s = substr($s,0,81);
					# clé convertie :
					# 67A1249B51AD71D452BF612572B5BE2530EC7F3F.9331D6D73814DBEE129E0F2D46E4CBFA285E5930
				} elsif (length($args{s}) == 88) {
					if ($args{key} eq "yt6") { # pas sûr du tout !
						my $pre = substr($args{s},0,1);
						$s = reverse($args{s});
						substr($s,2,2) = "";
						substr($s,43,1) = $pre;
						$s = substr($s,0,81);
					} else {
						my $pre = substr($args{s},0,1);
						$s = substr(delete $args{s},1);
						my $post = substr($s,length($s)-6);
						my $s2 = "";
						for (my $n=length($s)-7; $n>=0; $n--) {
							$s2 .= substr($s,$n,1);
						}
						$s = $s2;
						my $prev = substr($s,16,1);
						substr($s,16,1) = substr($post,2,1);
						substr($s,21,1) = $prev;
						substr($s,49,1) = $pre;
					}
				} elsif (length($args{s}) == 84) {
					$s = substr(reverse(delete $args{s}),1);
					my $post = substr($s,0,1);
					$s = substr($s,1);
					my $pre = substr($s,0,1);
					substr($s,0,1) = substr($s,39,1);
					substr($s,39,1) = $pre;
					substr($s,20,1) = substr($s,26,1);
					substr($s,26,1) = $post;
					substr($s,56,1) = substr($s,81,1);
					substr($s,81,1) = "";
				} elsif (length($args{s}) == 82) {
					$s = delete $args{s};
					my $pre = substr($s,0,1);
					my $old = $s = substr($s,1);
					substr($s,14,1) = substr($s,36,1);
					substr($s,36,1) = substr($s,0,1);
					substr($s,0,1) = substr($old,14,1);
					substr($s,2,1) = $pre;
					substr($s,41,1) = substr($s,80,1);
					substr($s,80,1) = substr($old,41,1);
					substr($s,50,1) = substr($old,2,1);
				} elsif (length($args{s}) == 83) {
					# url originale
					# s=073AAC043F70F58C8CFADBAF38B2F3D7935439026.C8BD1CCFA2117B4AFB25C230547A310C2AB2D93EE
					# https://r5---sn-25ge7nl6.googlevideo.com/videoplayback?expire=1449684773&gcr=fr&itag=160&keepalive=yes&requiressl=yes&ms=au&mv=m&mt=1449663065&sparams=clen,dur,gcr,gir,id,initcwndbps,ip,ipbits,itag,keepalive,lmt,mime,mm,mn,ms,mv,nh,pl,requiressl,source,upn,expire&pl=47&id=o-AErYrG8stYzRckK7GxXbjAVt9EN0_s9xSw_IVDKHvCyq&mime=video/mp4&sver=3&lmt=1434106452912156&gir=yes&mn=sn-25ge7nl6&ip=2001:41d0:fe0b:6d00:7a34:fe66:1360:c62f&mm=31&ipbits=0&upn=IypybhqI7pY&initcwndbps=2805000&source=youtube&dur=284.283&clen=3873553&nh=IgpwcjAxLnBhcjAxKgkxMjcuMC4wLjE&
					# fexp=9406819,9414602,9416126,9418203,9418751,9420452,9420771,9422596,9423241,9423329,9423662,9424163,9424428,9424713,9425308&
					#
					# key=yt6&type=video/mp4;+codecs="avc1.4d400c"&itag=160&lmt=1434106452912156&quality_label=144p&init=0-671&projection_type=1&fps=15&clen=3873553,size=192x144
					# signature décodée :
					# 73AAC043F70F58C8CFADBAF38B2F3D0935439026.C8BD1CCFA2117B4AFB25C230547A310C2AB2D93E
					if ($args{key} eq "yt6") { # ???
						$s = delete $args{s};
						my $pre = substr($s,0,1);
						$s = substr($s,1,81);
						substr($s,30,1) = $pre;
					} else {
						my $old = $s = delete $args{s};
						substr($s,0,1) = substr($s,43,1);
						substr($s,43,1) = substr($old,0,1);
						substr($s,81) = "";
					}
				}
				$s = undef if (length($s) != 81);
				print STDERR "sig2: $s (",length($s),")\n" if ($debug);
			}
			my $q = delete $args{quality};
			$q = delete $args{size} if (!$q);
			$q =~ s/,.+//;
			delete $args{index};
			my $bitrate = delete $args{bitrate};
			delete $args{init};
			$last = $q;
			$type =~ s/;.+//;
			if ($s) {
				$u = delete $args{url};
				$u .= "?";
				foreach (keys %args) {
					$u .= "&$_=".$args{$_};
				}
				print STDERR "processing q=$q type=$type bitrate=$bitrate\n" if ($debug);
				# Sépare les pistes audio pour les adaptive
				if ($type !~ /^audio/) {
					# Il faut garder le titre ici pour le bandeau d'info...
					push @name,"$title $q $type"; # on laisse tomber le bitrate
					push @url,"$u&signature=$s";
				} else {
					$audio = "$u&signature=$s";
				}
			}
		}
		if ($audio) {
			foreach (@url) {
				$_ .= " $audio";
			}
		}
		print STDERR "in ze end : $#name names\n" if ($debug);
		for (my $n=0; $n<=$#name; $n++) {
			print "$name[$n]\n$url[$n]\n";
		}
		# return $url;
	}
}

